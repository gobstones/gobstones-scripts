/*
 * *****************************************************************************
 * Copyright (C) National University of Quilmes 2018-2024
 * Gobstones (TM) is a trademark of the National University of Quilmes.
 *
 * This program is free software distributed under the terms of the
 * GNU Affero General Public License version 3.
 * Additional terms added in compliance to section 7 of such license apply.
 *
 * You may read the full license at https://gobstones.github.io/gobstones-guidelines/LICENSE.
 * *****************************************************************************
 */

/**
 * @module Config
 * @author Alan Rodas Bonjour <alanrodas@gmail.com>
 */
import path from 'path';
import { fileURLToPath } from 'url';

import { ConfigEnvironment, environment } from './helpers/environment';
import { ConfigExecutionEnvironment, executionEnvironment } from './helpers/execution-environment';
import {
    ConfigFilteredProjectTypes,
    FilteredFilesDefinition,
    filteredProjectTypes
} from './helpers/filtered-project-types';
import { ConfigLocations, locations } from './helpers/locations';
import { ConfigPackageManagers, PackageManagerDefinition, availablePackageManagers } from './helpers/package-managers';
import {
    ConfigProjectTypes,
    FileName,
    GeneratableFileDefinitionWithTooling,
    ProjectTypeDefinition,
    projectTypes
} from './helpers/project-types';
import { ExecutableScriptDefinition } from './helpers/scripts';

import { getBin } from '../Helpers/getBin';
import { LogLevel, logger } from '../Helpers/Logger';
import { unglob } from '../Helpers/unglob';
import { deepMerge } from '../Helpers/deepMerge';

/**
 * This class represents the main configuration object generated by the application.
 * The configuration is automatically loaded once the {@link init} method is called.
 * This object is also the main entry point to obtain configuration options of the tool
 * as to obtain the located directories, tooling files and obtain location for the
 * executable scripts for different tools.
 */
export class Config {
    // ------------------------------------------
    // #region Private Properties
    // ------------------------------------------
    /** Whether the configuration has been initialized. */
    private _lastInitializationValues?: {
        apiGivenProjectType?: string;
        apiGivenPackageManager?: string;
        debug: boolean;
        test: boolean;
    };

    /** The subpart of the configuration corresponding to package managers. */
    private _packageManagers: ConfigPackageManagers;
    /** The subpart of the configuration corresponding to the environment. */
    private _environment: ConfigEnvironment;
    /** The subpart of the configuration corresponding to the different path locations. */
    private _locations: ConfigLocations;
    /** The subpart of the configuration corresponding to the current execution environment. */
    private _executionEnvironment: ConfigExecutionEnvironment;
    /** The subpart of the configuration corresponding to the different project types. */
    private _projectTypes: ConfigProjectTypes;
    /** The subpart of the configuration corresponding to the different project type filtered files. */
    private _filteredProjectTypes: ConfigFilteredProjectTypes;
    /** A cache for the executable scripts already detected. */
    private _binaryFilesCache: Record<string, ExecutableScriptDefinition | undefined>;
    // ------------------------------------------
    // #endregion Private Properties
    // ------------------------------------------

    /**
     * This helpers allow configuration files to access different needs
     * that have no place anywhere else.
     *
     * @privateRemarks
     * This violates the cohesive nature of the object, but most config files
     * for tools, such as ESLint or Jest are importing the configuration, so
     * it is easy to provide the tools there.
     */
    public readonly helpers = {
        unglob,
        deepMerge,
        basePathFor: (url: string, filename?: string) => {
            const baseUrl = path.resolve(path.dirname(fileURLToPath(url)));
            return filename !== undefined ? path.join(baseUrl, filename) : baseUrl;
        },
        setToAll: <T>(list: T[], key: string, value: T): T[] =>
            list.map((e) => {
                e[key] = value;
                return e;
            })
    };

    /**
     * Create a new instance of the configuration.
     */
    public constructor() {
        /*
         * We need to set the logger on if debug was sent from the CLI,
         * as this i the first thing that happens, even after running any code.
         * This is clearly a violation of the concern of 'config', but
         * there doesn't seem to be a better way without recurring to
         * dynamic imports, which implies changing the build system.
         */
        if (process.argv.includes('-D') || process.argv.includes('--debug')) {
            logger.level = LogLevel.Debug;
            logger.on();
        }
        logger.debug('[config] Creating configuration object');
        // has not yet been initialized
        this._lastInitializationValues = undefined;
        this._binaryFilesCache = {};
    }

    // ------------------------------------------
    // #region Accessing
    // ------------------------------------------
    /** Returns the subpart of the configuration corresponding to package managers. */
    public get packageManagers(): ConfigPackageManagers {
        return this._packageManagers;
    }

    /** Returns subpart of the configuration corresponding to the environment. */
    public get environment(): ConfigEnvironment {
        return this._environment;
    }

    /** Returns the subpart of the configuration corresponding to the different path locations. */
    public get locations(): ConfigLocations {
        return this._locations;
    }

    /** Returns the subpart of the configuration corresponding to the current execution environment. */
    public get executionEnvironment(): ConfigExecutionEnvironment {
        return this._executionEnvironment;
    }

    /** Returns the subpart of the configuration corresponding to the different project types. */
    public get projectTypes(): ConfigProjectTypes {
        return this._projectTypes;
    }

    /** The subpart of the configuration corresponding to the different project type filtered files. */
    public get filteredProjectTypes(): ConfigFilteredProjectTypes {
        return this._filteredProjectTypes;
    }

    public get packageManager(): PackageManagerDefinition {
        return this._packageManagers[this._executionEnvironment.packageManager];
    }

    public get projectType(): ProjectTypeDefinition {
        return this._projectTypes[this._executionEnvironment.projectType];
    }

    public get projectTypeFilteredFiles(): FilteredFilesDefinition {
        return this._filteredProjectTypes[this._executionEnvironment.projectType];
    }

    public get projectTypeGenerateableFiles(): Partial<Record<FileName, Record<string, string>>> {
        const generatableFiles: Partial<Record<FileName, Record<string, string>>> = {};
        for (const fileItem of Object.keys(this.projectType)) {
            const fileDef = this.projectType[fileItem] as GeneratableFileDefinitionWithTooling;
            if (!fileDef.toolingFiles && fileDef.generatableFiles) {
                generatableFiles[fileDef.name] = fileDef.generatableFiles;
            }
        }
        return generatableFiles;
    }
    // ------------------------------------------
    // #endregion Accessing
    // ------------------------------------------

    // ------------------------------------------
    // #region Initialization
    // ------------------------------------------
    /**
     * Orchestrate the initialization of the Config object.
     * This initialization is needed in order to access any of the
     * sub-configuration sections, except for retrieving
     * executable scripts.
     */
    public init(apiGivenProjectType?: string, apiGivenPackageManager?: string, debug?: boolean, test?: boolean): this {
        if (!this._lastInitializationValues) {
            logger.debug(`[config] Initializing configuration from scratch`);

            this._packageManagers = availablePackageManagers();
            this._environment = environment(this._packageManagers);
            this._locations = locations(this._environment.operatingSystem);
            this._projectTypes = projectTypes(this._locations);
            this._filteredProjectTypes = filteredProjectTypes(this._projectTypes);
        }

        if (
            !this._lastInitializationValues ||
            (apiGivenProjectType && this._lastInitializationValues.apiGivenProjectType !== apiGivenProjectType) ||
            (apiGivenPackageManager &&
                this._lastInitializationValues.apiGivenPackageManager !== apiGivenPackageManager) ||
            (debug && this._lastInitializationValues.debug !== debug) ||
            (test && this._lastInitializationValues.test !== test)
        ) {
            logger.debug(`[config] Already initialized, updating CLI/API parameters`);
            this._executionEnvironment = executionEnvironment(
                {
                    projectTypes: this._projectTypes,
                    packageManagers: this._packageManagers,
                    locations: this._locations
                },
                apiGivenProjectType,
                apiGivenPackageManager,
                debug,
                test
            );
            this._lastInitializationValues = this._executionEnvironment;
        }
        return this;
    }

    /**
     * Change the current directory of the process to another one.
     * Additionally, update the global configuration to match.
     *
     * @param dir - The directory to change to
     */
    public changeDir(dir: string): string {
        process.chdir(dir);
        this._environment.workingDirectory = dir;
        this._locations.projectRoot = dir;
        return dir;
    }

    /**
     * Return the information for executing a binary file, if it can be found
     * by the configuration system. Additionally, and differently from the
     * simple getBin helper, this method provides caching, as to not
     * attempt to find the element twice.
     *
     * @param packageName - The package name that contains the binary file.
     * @param binName - The binary file to execute.
     *
     * @returns The executable to run, or undefined if not found.
     */
    public getBinary(packageName: string, binName: string): ExecutableScriptDefinition | undefined {
        if (!this._binaryFilesCache[`${packageName}-${binName}`]) {
            this._binaryFilesCache[`${packageName}-${binName}`] = getBin(
                this._locations.projectRoot,
                this.packageManager,
                packageName,
                binName
            );
        }
        return this._binaryFilesCache[`${packageName}-${binName}`];
    }
}
// ==========================================
// #endregion Config
// ==========================================

// ==========================================
// #region Config Instance
// ==========================================
/**
 * The config object exports all configuration functions in
 * a convenient element.
 *
 * @internal
 */
export const config: Config = new Config();
// ==========================================
// #endregion Config Instance
// ==========================================
